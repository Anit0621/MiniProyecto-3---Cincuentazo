package com.example._50zo.controller;

import com.example._50zo.model.*;
import com.example._50zo.view.EndStage;
import com.example._50zo.view.GameStage;
import javafx.application.Platform;
import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.GridPane;
import com.example._50zo.view.StartStage;



import java.io.IOException;
import java.io.InputStream;
import java.util.*;
/**
 * Controller class responsible for handling all game-related UI interactions
 * and updating the visual state of the game.
 * <p>
 * This controller manages player actions, machine (AI) turns, card rendering,
 * and communication between the user interface and the underlying game logic.
 * It acts as the main bridge between the view (JavaFX) and the game model.
 * </p>
 */

public class GameController {

    @FXML
    private TextArea gameMessages;

    @FXML
    private GridPane machine1GridPane;

    @FXML
    private GridPane machine2GridPane;

    @FXML
    private GridPane machine3GridPane;

    @FXML
    private GridPane playerGridPane;

    @FXML

    private ImageView tableImageView;

    @FXML
    private Label tableSum;

    /**
     * The numbers of players set for the current game.
     */

    private int numPlayers;

    /**
     * The {@code Game} instance assigned to this controller.
     */

    private Game game;

    /**
     * The {@code Deck} object used in the current round.
     */

    private Deck deck;

    /**
     * instance of {@code Random} used for shuffling the deck.
     */

    private Random random;

    /**
     * Indicates whether the player must draw a card.
     * <p>
     * This flag becomes {@code true} when the game logic requires the player
     * to draw a card, and {@code false} otherwise.
     * </p>
     */

    private boolean mustDrawCard = false;

    /**
     * Initializes the GameController automatically, setting the number of players, initializing the game variables
     * such as Deck, assigning the Controller to the Game instance and printing both the human and machine's hands.
     *
     * Deletes the StartStage instance, closing the StartStage window.
     */


    @FXML
    public void initialize() throws IOException {
        setNumPlayers(askNumberOfPlayers());
        initVariables();
        StartStage.deleteInstance();
        gameMessages.setStyle("-fx-text-alignment: center; -fx-alignment: center;");
    }

    /**
     * Initializes and assigns starting values to the Game variables like the number of players,
     * the controller for the game, the initial sum on the table, prints both the human and machine player's hands
     * and plays the first card, adding its corresponding value to the table.
     */


    public void initVariables() {
        this.game = new Game(numPlayers);
        game.setController(this);
        int intTableSum = Integer.parseInt(tableSum.getText());
        intTableSum = game.getTableSum();
        this.game.initializeGame();
        printCardsHumanPlayer();
        printCardsMachinePlayers();
        playFirstCard();



    }

    /**
     * Handles the action triggered when the player clicks to take a card.
     *
     * @param event the {@link MouseEvent} generated by the user's interaction.
     * Checks whether the player has already drawn a card from the deck and prompts them to do so.
     * Shows an error message in case there's an error grabbing the card from the deck.
     *
     */


    @FXML
    void handleTakeCard(MouseEvent event) {
        try {
            Player humanplayer = game.getPlayers().get(0);

            if (!mustDrawCard) {
                showMessage("Primero debes jugar una carta antes de tomar del mazo.");
                return;
            }

            if (!game.getDeck().isEmpty()) {
                Card newCard = game.getDeck().drawCard();
                humanplayer.addCard(newCard);
                printCardsHumanPlayer();
                showMessage("Has tomado una nueva carta: " + newCard);

                mustDrawCard = false;
            } else {
                showMessage("El mazo está vacío. No hay más cartas para tomar.");
            }

        } catch (Exception e) {
            showMessage("Error al tomar una carta: " + e.getMessage());
        }
    }

    /**
     * Sets the number of players for this game.
     */

    public void setNumPlayers(int numPlayers) {
        this.numPlayers = numPlayers;
    }

    /**
     * Prompts the player to type the number of players for the round.
     * Shows a warning in case no number is typed in, if the number of players is less than 2 or greater than 4 and
     *  if the player types a non-number character, recursively calling itself to ask for the number of players.
     */

    private int askNumberOfPlayers() {
        TextInputDialog dialog = new TextInputDialog();
        dialog.setTitle("Número de jugadores");
        dialog.setHeaderText("Configura la partida");
        dialog.setContentText("¿Cuántos jugadores participarán?");

        Optional<String> result = dialog.showAndWait();
        if (result.isPresent()) {
            try {
                int num = Integer.parseInt(result.get());
                if (num < 2 || num > 4) {
                    System.out.println(num);
                    Alert alert = new Alert(Alert.AlertType.WARNING);
                    alert.setTitle("Acción inválida");
                    alert.setHeaderText("Numero de jugadores invalido");
                    DialogPane dialogPane = alert.getDialogPane();
                    dialogPane.getStylesheets().add(getClass().getResource("/styles.css").toExternalForm());
                    dialogPane.getStyleClass().add("warning-label");
                    alert.showAndWait();

                    return askNumberOfPlayers();

                }
                return num;


            } catch (NumberFormatException e) {
                Alert alert = new Alert(Alert.AlertType.WARNING);
                alert.setTitle("Acción inválida");
                alert.setHeaderText("Debe ingresar un número");
                alert.showAndWait();
                return askNumberOfPlayers();

            }
        }
        return 1;
    }

    /**
     * Graphically displays the human player's hand of cards, printing them in the bottom center part of the
     * screen and facing up so that the player can see the suit and value of each of their cards.
     *
     */

    private void printCardsHumanPlayer() {
        playerGridPane.getChildren().clear();

        Player humanPlayer = game.getPlayers().get(0);

        int col = 0;
        for (Card card : humanPlayer.getHand()) {
            try {
                showMessage("Cargando imagen: " + card.getImagePath());
                Image cardImage = new Image(getClass().getResourceAsStream(card.getImagePath()));
                ImageView imageView = new ImageView(cardImage);
                imageView.setFitWidth(80);
                imageView.setFitHeight(90);
                imageView.setPreserveRatio(true);

                playerGridPane.add(imageView, col++, 0);

                imageView.setOnMouseClicked(e -> {
                    if (mustDrawCard) {
                        showMessage("Debes tomar una carta del mazo antes de jugar otra.");
                    } else {
                        humanPlayer.removeCard(card);
                        updateTableSumAndView(card);
                        printCardsHumanPlayer();

                        mustDrawCard = true;

                        if (!humanPlayer.canPlay(game.getTableSum())) {
                            System.out.println("Esta entrando aqui? suma de la mesa: " + game.getTableSum());
                            showMessage("No puedes jugar más cartas. Has sido eliminado.");
                            game.eliminatePlayer(humanPlayer);

                            if (!game.isGameOver()) {
                                new Thread(() -> continueMachinesAfterHumanLost()).start();
                            }
                        } else {
                            new Thread(() -> playMachinesTurn()).start();
                            System.out.println();
                        }
                    }
                });


            } catch (Exception e) {
                showMessage("No se pudo cargar la imagen de la carta " + card.getImagePath());
            }
        }
    }

    /**
     * Updates the UI to display the cards of all machine (AI) players.
     * <p>
     * This method clears the existing card views in each machine player's
     * {@code GridPane} and redraws the card backs to visually represent
     * the cards held by each machine player. Since machine players'
     * cards are hidden from the user, only the back image is shown.
     * </p>
     * <p>
     * The number of machine players is determined as {@code numPlayers - 1},
     * assuming the first player (index 0) is the human player.
     * </p>
     *
     * @see Player
     * @see Game#getPlayers()
     */


    private void printCardsMachinePlayers() {
        if (machine1GridPane != null) machine1GridPane.getChildren().clear();
        if (machine2GridPane != null) machine2GridPane.getChildren().clear();
        if (machine3GridPane != null) machine3GridPane.getChildren().clear();

        Image backImage = new Image(getClass().getResourceAsStream("/images/back.png"));

        int numMachines = numPlayers - 1;

        for (int i = 1; i <= numMachines; i++) {
            Player machine = game.getPlayers().get(i);

            for (int j = 0; j < machine.getHand().size(); j++) {
                ImageView cardBack = new ImageView(backImage);
                cardBack.setFitWidth(80);
                cardBack.setFitHeight(90);
                cardBack.setPreserveRatio(true);

                if (i == 1 && machine1GridPane != null) {
                    machine1GridPane.add(cardBack, 0, j);
                } else if (i == 2 && machine2GridPane != null) {
                    machine2GridPane.add(cardBack, j, 0);
                } else if (i == 3 && machine3GridPane != null) {
                    machine3GridPane.add(cardBack, 0, j);
                }
            }
        }
    }

    /**
     * Graphically updates the card shown in the center of the table, setting the played card's image as
     * the image shown.
     *
     */


    public void updateTableSumAndView(Card card) {
        Platform.runLater(() -> {
            int currentSum = Integer.parseInt(tableSum.getText());
            int valueToSum = card.getGameValue(currentSum);
            currentSum += valueToSum;
            game.setTableSum(currentSum);
            tableSum.setText(String.valueOf(currentSum));
            tableImageView.setImage(new Image(getClass().getResourceAsStream(card.getImagePath())));
            System.out.println("Nueva suma en la mesa " + currentSum);
            showMessage("Nueva suma en la mesa: " + currentSum);


        });
    }

    /**
     * Picks a random card from the deck and places it on the table, effectively starting the game.
     *
     */

    private void playFirstCard(){
        deck = game.getDeck();
        Random random = new Random();
        Stack<Card> cards = deck.getCards();
        Card randomCard = cards.pop();
        updateTableSumAndView(randomCard);
    }

    /**
     * Executes the turn logic for all machine (AI) players.
     * <p>
     * This method creates a snapshot of the current list of players and then
     * iterates over it to avoid concurrent modification issues while the game
     * state is being updated. For each player identified as a machine player,
     * the corresponding AI turn logic is executed.
     * </p>
     *
     * <p>
     * Machine players are typically instances of {@code MachinePlayer} (or similar),
     * determined using {@code instanceof}. The actual behavior executed during the
     * machine's turn depends on the specific implementation of the AI logic.
     * </p>
     *
     * @see Player
     * @see MachinePlayer
     * @see Game#getPlayers()
     */

    private void playMachinesTurn() {
        List<Player> currentPlayers = new ArrayList<>(game.getPlayers());

        for (Player player : currentPlayers) {
            if (player instanceof MachinePlayer && !player.isEliminated()) {
                String name = player.getName();

                if ((name.equals("maquina 1") && machine1GridPane != null)
                        || (name.equals("maquina 2") && machine2GridPane != null)
                        || (name.equals("maquina 3") && machine3GridPane != null)) {
                    System.out.println("al jugar las maquinas, la suma es: " + Integer.parseInt(tableSum.getText()));
                    game.playTurn(player);
                }
            }
        }

        game.removeEliminatedPlayers();
        System.out.println("Turno del jugador, suma de la mesa: " + Integer.parseInt(tableSum.getText()));
    }


    private void continueMachinesAfterHumanLost() {
        System.out.println("El jugador humano ha sido eliminado. Las máquinas seguirán jugando...");
        showMessage("El jugador humano ha sido eliminado. Las máquinas seguirán jugando...");

        while (!game.isGameOver()) {
            List<Player> currentPlayers = new ArrayList<>(game.getPlayers());

            for (Player player : currentPlayers) {
                if (player instanceof MachinePlayer && !player.isEliminated()) {
                    game.playTurn(player);

                    try {
                        Thread.sleep((int)(Math.random() * 2000) + 2000);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            }

            game.removeEliminatedPlayers();

        }
    }
    /**
     * Handles the end of the game by closing the current GameStage
     * and showing the EndStage with the winner's information.
     *
     * @param winnerName the name of the winner
     * @param playerWon true if the human player won, false if a machine won
     */
    public void onGameEnded(String winnerName, boolean playerWon) throws IOException{
        Platform.runLater(() -> {
            try {
                EndStage endStage = EndStage.getInstance();
                EndController endController = endStage.getController();

                endController.setWinnerName(winnerName);

            } catch (Exception e) {
                e.printStackTrace();
            }

            try {
                if (StartStage.getInstance() != null) {
                    StartStage.deleteInstance();
                }

            } catch (IOException e) {
                e.printStackTrace();
            }


                javafx.stage.Stage currentStage = (javafx.stage.Stage) tableImageView.getScene().getWindow();
                currentStage.close();

        });
    }

    /**
     * Displays a message in the game's text area safely from any thread.
     * Ensures UI updates happen on the JavaFX Application Thread.
     *
     * @param message The message to display
     */
    public void showMessage(String message) {
        javafx.application.Platform.runLater(() -> {
            gameMessages.setText(message);
        });
    }

}
